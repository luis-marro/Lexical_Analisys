import java_cup.runtime.*;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java_cup.runtime.Symbol;

parser code {:

    public ArrayList<String> syntaxErrors = new ArrayList<String>();

    public int errors = 0;
    public ArrayList<String> tableProcess = new ArrayList<String>(); // to print the table
    public ArrayList<int> indent = new ArrayList<int>(); // to keep track of table levels when printing


    public void syntax_error(Symbol symb){
        java_cup.runtime.Symbol s = (symb);
        System.out.println("*** Error Sintactico. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.toString() + "\' *** Mensaje Error: Simbolo no reconocido.");
        syntaxErrors.add("*** Error Sintactico. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.value + "\' *** Mensaje Error: Simbolo no reconocido.");
        errors++;
    }

    public void unrecovered_syntax_error(Symbol symb){
        java_cup.runtime.Symbol s = (symb);
        System.out.println("*** Error Sintactico No Recuperado. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.toString() + "\' *** Mensaje Error: Simbolo no reconocido.");
        syntaxErrors.add("*** Error Sintactico No Recuperado. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.value + "\' *** Mensaje Error: Simbolo no reconocido.");
        errors++;
    }

    public void semanticError (String lexeme, String message) {
            errors++;
         	System.err.println("Error "+ s.current_lexeme() + " : Semantic error");
            System.err.println("  "+ errors + "==> " + message + ": "+ lexeme + "\n");
      }

:};

/* Terminal tokens returned by the scanner */

terminal INT, DOUBLE, VOID, BOOL, STRING, CLASS, INTERFACE, NULL, THIS, EXTENDS;
terminal IMPLEMENTS, FOR, WHILE, IF, ELSE, RETURN, BREAK, NEW, NEWARRAY;
terminal PRINT, READINTEGER, READLINE, MALLOC, TWOBRACK, TWOCURLY, TWOPAR, PERCENT;
terminal LESST, GREATT, EQUALS, EXCLA, PAC, LEFTBRACKET, RIGHTBRACKET, LEFTPAR, RIGHTPAR;
terminal LEFTCURLY, RIGHTCURLY, LESSEQ, GTREQ, DIFFERENT, DIV, AND, OR, ADD, MINUS;
terminal MULT, DOT, COMMA, COMPEQUALS, GETBYTE, SETBYTE, CONST, ERROR;

/* Terminals that have values */
terminal INTCONST;
terminal DOUBLECONST;
terminal IDENTIFIER;
terminal STRINGCONST;
terminal TRUE;
terminal FALSE;

/* Non Terminals*/
non terminal program, decl, variableDecl, variable, type, functionDecl, decl_plus;
non terminal formals, formalsExt, classDecl, extendedIdent, impl, idenPlus, augField;
non terminal field, interfaceDecl, augPrototype, prototype, stmtBlock, variableDecAug;
non terminal stmtAug, stmt, ifStmt, elseStmt, whileStmt, forStmt, returnStmt, breakStmt;
non terminal printStmt, exprPlus, expr, optionalExpr, lvalue, call, libCall, actuals, constant;

/* Precedences */
precedence left EQUALS;
precedence left OR, AND;
precedence nonassoc LESST, LESSEQ, GREATT, GTREQ, COMPEQUALS, DIFFERENT ;
precedence left ADD, MINUS, MULT, DIV, PERCENT ;
precedence nonassoc EXCLA;
precedence nonassoc LEFTBRACKET, DOT;
precedence nonassoc ELSE;
precedence right COMMA;
/* Grammar */

start with program ;

program ::= decl decl_plus ;

decl_plus ::= decl_plus decl
            | /*Epsilon*/ ;

decl ::= variableDecl
            | functionDecl
            | classDecl
            | interfaceDecl
            | error PAC
            | error RIGHTCURLY ;

variableDecl ::= variable PAC ;

variable ::= type IDENTIFIER
            | CONST type IDENTIFIER ;

type ::= INT
            | DOUBLE
            | BOOL
            | STRING
            | IDENTIFIER
            | type TWOBRACK ;

functionDecl ::= type IDENTIFIER LEFTPAR formals RIGHTPAR stmtBlock
                    | VOID IDENTIFIER LEFTPAR formals RIGHTPAR stmtBlock
                    | type IDENTIFIER TWOPAR stmtBlock
                    | VOID IDENTIFIER TWOPAR stmtBlock;

formals ::= formalsExt
            | /*Epsilon */ ;

formalsExt ::= variable
                | formalsExt COMMA variable ;

classDecl ::= CLASS IDENTIFIER:id impl LEFTCURLY augField RIGHTCURLY {: System.out.println("Funciona la declaracion de codigo");  :}
                | CLASS IDENTIFIER EXTENDS IDENTIFIER impl LEFTCURLY augField RIGHTCURLY
                | CLASS IDENTIFIER impl TWOCURLY
                | CLASS IDENTIFIER EXTENDS IDENTIFIER impl TWOCURLY ;


impl ::= IMPLEMENTS idenPlus
            | /*EPSILON */ ;

idenPlus ::= IDENTIFIER
                | idenPlus COMMA IDENTIFIER ;

augField ::= augField field
                | /*Epsilon */ ;

field ::= variableDecl
                | functionDecl ;

interfaceDecl ::= INTERFACE IDENTIFIER LEFTCURLY augPrototype RIGHTCURLY
                    | INTERFACE IDENTIFIER TWOCURLY  ;

augPrototype ::= augPrototype prototype
                    | /*Epsilon */ ;

prototype ::= type IDENTIFIER LEFTPAR formals RIGHTPAR PAC
                | VOID IDENTIFIER LEFTPAR formals RIGHTPAR PAC
                | type IDENTIFIER TWOPAR PAC
                | VOID IDENTIFIER TWOPAR PAC ;

stmtBlock ::= LEFTCURLY variableDecAug stmtAug RIGHTCURLY
                | TWOBRACK ;

variableDecAug ::= variableDecAug variableDecl
                    | /*Epsilon */ ;

stmtAug ::= stmt stmtAug
            | /*Espsilon */ ;

stmt ::= expr PAC
            | PAC
            | ifStmt
            | whileStmt
            | forStmt
            | breakStmt
            | returnStmt
            | printStmt
            | stmtBlock ;

ifStmt ::= IF LEFTPAR expr RIGHTPAR stmt elseStmt;

optionalExpr ::= expr
                | /*Epsilon */ ;

elseStmt ::= ELSE stmt
                | /*Epsilon */ ;

whileStmt ::= WHILE LEFTPAR expr RIGHTPAR stmt ;

forStmt ::= FOR LEFTPAR optionalExpr PAC expr PAC optionalExpr RIGHTPAR stmt ;

returnStmt ::= RETURN optionalExpr PAC ;

breakStmt ::= BREAK PAC ;

printStmt ::= PRINT LEFTPAR expr exprPlus RIGHTPAR PAC ;

exprPlus ::= COMMA expr exprPlus
                | /*Epsilon*/ ;

expr ::= lvalue EQUALS expr
                | constant
                | lvalue
                | THIS
                | call
                | LEFTPAR expr RIGHTPAR
                | expr ADD expr
                | expr MINUS expr
                | expr MULT expr
                | expr DIV expr
                | expr PERCENT expr
                | MINUS expr
                | expr LESST expr
                | expr LESSEQ expr
                | expr GTREQ expr
                | expr GREATT expr
                | expr COMPEQUALS expr
                | expr DIFFERENT expr
                | expr AND expr
                | expr OR expr
                | EXCLA expr
                | NEW LEFTPAR IDENTIFIER RIGHTPAR
                | NEWARRAY LEFTPAR expr COMMA type RIGHTPAR
                | READINTEGER TWOPAR
                | READLINE TWOPAR
                | MALLOC LEFTPAR expr RIGHTPAR ;

lvalue ::= IDENTIFIER
                | expr DOT IDENTIFIER
                | expr LEFTBRACKET expr RIGHTBRACKET ;

call ::= IDENTIFIER LEFTPAR actuals RIGHTPAR
                | IDENTIFIER TWOPAR
                | expr DOT IDENTIFIER LEFTPAR actuals RIGHTPAR
                | expr DOT IDENTIFIER TWOPAR
                | expr DOT libCall LEFTPAR actuals RIGHTPAR
                | expr DOT libCall TWOPAR ;

libCall ::= GETBYTE LEFTPAR expr RIGHTPAR
                | SETBYTE LEFTPAR expr COMMA expr RIGHTPAR ;

actuals ::= expr exprPlus
                | /*Epsilon */ ;

constant ::= INTCONST
                | DOUBLECONST
                | TRUE
                | FALSE
                | STRINGCONST
                | NULL ;